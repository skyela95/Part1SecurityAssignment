diff --git a/dh/__init__.py b/dh/__init__.py
index 6d6f182..a363340 100644
--- a/dh/__init__.py
+++ b/dh/__init__.py
@@ -2,39 +2,67 @@ from Crypto.Hash import SHA256
 from Crypto.Random import random
 
 from lib.helpers import read_hex
+#from time import time
 
-# Project TODO: Is this the best choice of prime? Why? Why not? Feel free to replace!
+# Project TODO: Is this the best choice of prime? Why? Why not? Feel free to REPLACE!
 
-# 1536 bit safe prime for Diffie-Hellman key exchange
+# 4096 bit safe prime for Diffie-Hellman key exchange
 # obtained from RFC 3526
 raw_prime = """FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1
-29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
-EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
-E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED
-EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3D
-C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F
-83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D
-670C354E 4ABC9804 F1746C08 CA237327 FFFFFFFF FFFFFFFF"""
+      29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
+      EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
+      E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED
+      EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3D
+      C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F
+      83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D
+      670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B
+      E39E772C 180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9
+      DE2BCBF6 95581718 3995497C EA956AE5 15D22618 98FA0510
+      15728E5A 8AAAC42D AD33170D 04507A33 A85521AB DF1CBA64
+      ECFB8504 58DBEF0A 8AEA7157 5D060C7D B3970F85 A6E1E4C7
+      ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226 1AD2EE6B
+      F12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200C
+      BBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB31
+      43DB5BFC E0FD108E 4B82D120 A9210801 1A723C12 A787E6D7
+      88719A10 BDBA5B26 99C32718 6AF4E23C 1A946834 B6150BDA
+      2583E9CA 2AD44CE8 DBBBC2DB 04DE8EF9 2E8EFC14 1FBECAA6
+      287C5947 4E6BC05D 99B2964F A090C3A2 233BA186 515BE7ED
+      1F612970 CEE2D7AF B81BDD76 2170481C D0069127 D5B05AA9
+      93B4EA98 8D8FDDC1 86FFB7DC 90A6C08F 4DF435C9 34063199
+      FFFFFFFF FFFFFFFF"""
 # Convert from the value supplied in the RFC to an integer
 prime = read_hex(raw_prime)
+g = 2
+
 
 # Project TODO: write the appropriate code to perform DH key exchange
 
-def create_dh_key():
+def create_dh_key(): #g, prime
     # Creates a Diffie-Hellman key
     # Returns (public, private)
-    a = random.randint(0, int(2**8))
-    return (a, a)
+    my_private_key = (random.randint(0, prime)) #maybe?Another source of rand?              Uses prime?
+    my_public_key = pow(g, my_private_key, prime)
 
-def calculate_dh_secret(their_public, my_private):
-    # Calculate the shared secret
-    shared_secret = their_public * my_private
+    #my_private_key = (the ** a) % prime
+    #a = random.randint(0, int(2**8))
+    #print(my_private_key, my_private_key)
+    return (my_public_key, my_private_key)
 
+def calculate_dh_secret(their_public_key, my_private_key):
+    # Calculate the shared secret
+    #shared_secret = their_public * my_private
+    shared_secret = pow(their_public_key, my_private_key, prime)
     # Hash the value so that:
     # (a) There's no bias in the bits of the output
     #     (there may be bias if the shared secret is used raw)
     # (b) We can convert to raw bytes easily
     # (c) We could add additional information if we wanted
     # Feel free to change SHA256 to a different value if more appropriate
-    shared_hash = SHA256.new(bytes(shared_secret, "ascii")).hexdigest()
+    ##sticking with 256 as others seem to be more easily broken
+    shared_hash = SHA256.new(bytes(str(shared_secret), "ascii")).hexdigest()
+    #[:shortened_to]
     return shared_hash
+
+
+
+#2042 bit min rec 4096
diff --git a/dh/__pycache__/__init__.cpython-34.pyc b/dh/__pycache__/__init__.cpython-34.pyc
index 92fa0df..ff9e5da 100644
Binary files a/dh/__pycache__/__init__.cpython-34.pyc and b/dh/__pycache__/__init__.cpython-34.pyc differ
diff --git a/dh/__pycache__/__init__.cpython-35.pyc b/dh/__pycache__/__init__.cpython-35.pyc
new file mode 100644
index 0000000..8fe3f86
Binary files /dev/null and b/dh/__pycache__/__init__.cpython-35.pyc differ
diff --git a/final.diff b/final.diff
new file mode 100644
index 0000000..3c5c9f5
--- /dev/null
+++ b/final.diff
@@ -0,0 +1,91 @@
+diff --git a/dh/__init__.py b/dh/__init__.py
+index 6d6f182..a363340 100644
+--- a/dh/__init__.py
++++ b/dh/__init__.py
+@@ -2,39 +2,67 @@ from Crypto.Hash import SHA256
+ from Crypto.Random import random
+ 
+ from lib.helpers import read_hex
++#from time import time
+ 
+-# Project TODO: Is this the best choice of prime? Why? Why not? Feel free to replace!
++# Project TODO: Is this the best choice of prime? Why? Why not? Feel free to REPLACE!
+ 
+-# 1536 bit safe prime for Diffie-Hellman key exchange
++# 4096 bit safe prime for Diffie-Hellman key exchange
+ # obtained from RFC 3526
+ raw_prime = """FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1
+-29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
+-EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
+-E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED
+-EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3D
+-C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F
+-83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D
+-670C354E 4ABC9804 F1746C08 CA237327 FFFFFFFF FFFFFFFF"""
++      29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
++      EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
++      E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED
++      EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3D
++      C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F
++      83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D
++      670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B
++      E39E772C 180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9
++      DE2BCBF6 95581718 3995497C EA956AE5 15D22618 98FA0510
++      15728E5A 8AAAC42D AD33170D 04507A33 A85521AB DF1CBA64
++      ECFB8504 58DBEF0A 8AEA7157 5D060C7D B3970F85 A6E1E4C7
++      ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226 1AD2EE6B
++      F12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200C
++      BBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB31
++      43DB5BFC E0FD108E 4B82D120 A9210801 1A723C12 A787E6D7
++      88719A10 BDBA5B26 99C32718 6AF4E23C 1A946834 B6150BDA
++      2583E9CA 2AD44CE8 DBBBC2DB 04DE8EF9 2E8EFC14 1FBECAA6
++      287C5947 4E6BC05D 99B2964F A090C3A2 233BA186 515BE7ED
++      1F612970 CEE2D7AF B81BDD76 2170481C D0069127 D5B05AA9
++      93B4EA98 8D8FDDC1 86FFB7DC 90A6C08F 4DF435C9 34063199
++      FFFFFFFF FFFFFFFF"""
+ # Convert from the value supplied in the RFC to an integer
+ prime = read_hex(raw_prime)
++g = 2
++
+ 
+ # Project TODO: write the appropriate code to perform DH key exchange
+ 
+-def create_dh_key():
++def create_dh_key(): #g, prime
+     # Creates a Diffie-Hellman key
+     # Returns (public, private)
+-    a = random.randint(0, int(2**8))
+-    return (a, a)
++    my_private_key = (random.randint(0, prime)) #maybe?Another source of rand?              Uses prime?
++    my_public_key = pow(g, my_private_key, prime)
+ 
+-def calculate_dh_secret(their_public, my_private):
+-    # Calculate the shared secret
+-    shared_secret = their_public * my_private
++    #my_private_key = (the ** a) % prime
++    #a = random.randint(0, int(2**8))
++    #print(my_private_key, my_private_key)
++    return (my_public_key, my_private_key)
+ 
++def calculate_dh_secret(their_public_key, my_private_key):
++    # Calculate the shared secret
++    #shared_secret = their_public * my_private
++    shared_secret = pow(their_public_key, my_private_key, prime)
+     # Hash the value so that:
+     # (a) There's no bias in the bits of the output
+     #     (there may be bias if the shared secret is used raw)
+     # (b) We can convert to raw bytes easily
+     # (c) We could add additional information if we wanted
+     # Feel free to change SHA256 to a different value if more appropriate
+-    shared_hash = SHA256.new(bytes(shared_secret, "ascii")).hexdigest()
++    ##sticking with 256 as others seem to be more easily broken
++    shared_hash = SHA256.new(bytes(str(shared_secret), "ascii")).hexdigest()
++    #[:shortened_to]
+     return shared_hash
++
++
++
++#2042 bit min rec 4096
+diff --git a/dh/__pycache__/__init__.cpython-34.pyc b/dh/__pycache__/__init__.cpython-34.pyc
+index 92fa0df..ff9e5da 100644
+Binary files a/dh/__pycache__/__init__.cpython-
\ No newline at end of file
diff --git a/lib/__pycache__/__init__.cpython-34.pyc b/lib/__pycache__/__init__.cpython-34.pyc
index 2b00042..773dfca 100644
Binary files a/lib/__pycache__/__init__.cpython-34.pyc and b/lib/__pycache__/__init__.cpython-34.pyc differ
diff --git a/lib/__pycache__/__init__.cpython-35.pyc b/lib/__pycache__/__init__.cpython-35.pyc
new file mode 100644
index 0000000..7ba4ffa
Binary files /dev/null and b/lib/__pycache__/__init__.cpython-35.pyc differ
diff --git a/lib/__pycache__/comms.cpython-34.pyc b/lib/__pycache__/comms.cpython-34.pyc
index e0f59a5..6c7394e 100644
Binary files a/lib/__pycache__/comms.cpython-34.pyc and b/lib/__pycache__/comms.cpython-34.pyc differ
diff --git a/lib/__pycache__/comms.cpython-35.pyc b/lib/__pycache__/comms.cpython-35.pyc
new file mode 100644
index 0000000..a48633c
Binary files /dev/null and b/lib/__pycache__/comms.cpython-35.pyc differ
diff --git a/lib/__pycache__/evil.cpython-34.pyc b/lib/__pycache__/evil.cpython-34.pyc
index 55a549c..ff0dfaf 100644
Binary files a/lib/__pycache__/evil.cpython-34.pyc and b/lib/__pycache__/evil.cpython-34.pyc differ
diff --git a/lib/__pycache__/evil.cpython-35.pyc b/lib/__pycache__/evil.cpython-35.pyc
new file mode 100644
index 0000000..0bd785f
Binary files /dev/null and b/lib/__pycache__/evil.cpython-35.pyc differ
diff --git a/lib/__pycache__/files.cpython-34.pyc b/lib/__pycache__/files.cpython-34.pyc
index b8d1fdd..43d165d 100644
Binary files a/lib/__pycache__/files.cpython-34.pyc and b/lib/__pycache__/files.cpython-34.pyc differ
diff --git a/lib/__pycache__/helpers.cpython-34.pyc b/lib/__pycache__/helpers.cpython-34.pyc
index 92554d0..5d90ba0 100644
Binary files a/lib/__pycache__/helpers.cpython-34.pyc and b/lib/__pycache__/helpers.cpython-34.pyc differ
diff --git a/lib/__pycache__/helpers.cpython-35.pyc b/lib/__pycache__/helpers.cpython-35.pyc
new file mode 100644
index 0000000..053d0ed
Binary files /dev/null and b/lib/__pycache__/helpers.cpython-35.pyc differ
diff --git a/lib/__pycache__/p2p.cpython-34.pyc b/lib/__pycache__/p2p.cpython-34.pyc
index cca9e4c..fd8c009 100644
Binary files a/lib/__pycache__/p2p.cpython-34.pyc and b/lib/__pycache__/p2p.cpython-34.pyc differ
diff --git a/lib/__pycache__/p2p.cpython-35.pyc b/lib/__pycache__/p2p.cpython-35.pyc
new file mode 100644
index 0000000..3ad7a18
Binary files /dev/null and b/lib/__pycache__/p2p.cpython-35.pyc differ
diff --git a/lib/comms.py b/lib/comms.py
index b67e767..5d92f59 100644
--- a/lib/comms.py
+++ b/lib/comms.py
@@ -1,18 +1,39 @@
 import struct
 
+import datetime
+
+import time
+
 from Crypto.Cipher import XOR
 
+from Crypto.Cipher import AES
+
+from Crypto.Hash import HMAC
+
+from Crypto.Hash import SHA256
+
+import random
+
 from dh import create_dh_key, calculate_dh_secret
 
+
 class StealthConn(object):
-    def __init__(self, conn, client=False, server=False, verbose=True):
+    def __init__(self, conn, client=False, server=False, verbose=False):
         self.conn = conn
         self.cipher = None
         self.client = client
         self.server = server
         self.verbose = verbose
+        self.shared_hash = None
+        self.shared_secret = None
+        self.iv = None
+        self.mac = None
+        self.key = None
+        self.timest = None
+        self.recvtimest = None
         self.initiate_session()
 
+		
     def initiate_session(self):
         # Perform the initial connection handshake for agreeing on a shared secret
 
@@ -25,27 +46,53 @@ class StealthConn(object):
             # Receive their public key
             their_public_key = int(self.recv())
             # Obtain our shared secret
-            shared_hash = calculate_dh_secret(their_public_key, my_private_key)
-            print("Shared hash: {}".format(shared_hash))
-
-        # Default XOR algorithm can only take a key of length 32
-        self.cipher = XOR.new(shared_hash[:4])
+            self.shared_secret = calculate_dh_secret(their_public_key, my_private_key)
+            self.shared_hash = SHA256.new(bytes(str(self.shared_secret), "ascii")).hexdigest()[:16]
+            print("Shared hash: {}".format(self.shared_hash))
+            self.key = self.shared_hash
+			
+        #creating iv
+        randSeed = random.seed(self.shared_hash)
+        self.iv = str(random.getrandbits(128))[:16]
+        print("IV is: {}".format(self.iv))
+		
+		#creating cipher
+        self.cipher = AES.new(self.shared_hash, AES.MODE_CBC, self.iv)
 
     def send(self, data):
         if self.cipher:
-            encrypted_data = self.cipher.encrypt(data)
-            if self.verbose:
+            #creating time stamp to prevent replay
+            self.timest = time.asctime()
+			#adding to data
+            dataToSend = data + self.timest.encode("ascii")
+			#encryting data
+            encrypted_data = self.encrypt(dataToSend, self.key)
+
+			#creating hmac with shared hash as key and encrypted data as msg
+            self.mac = HMAC.new(bytes.fromhex(self.shared_hash))
+            self.mac.update(encrypted_data)
+            sMac = self.mac.hexdigest()
+
+			#creating packet to send
+            packet_data = self.iv.encode("ascii") + sMac.encode("ascii") + encrypted_data
+            
+            if self.verbose:  
+                print("MAC is: {}".format(sMac))
+                print("Time: {}".format(self.timest))
                 print("Original data: {}".format(data))
                 print("Encrypted data: {}".format(repr(encrypted_data)))
-                print("Sending packet of length {}".format(len(encrypted_data)))
+                print("Packet data: {}".format(repr(packet_data)))
+                print("Sending packet of length {}".format(len(packet_data)))
         else:
-            encrypted_data = data
+            packet_data = data
 
         # Encode the data's length into an unsigned two byte int ('H')
-        pkt_len = struct.pack('H', len(encrypted_data))
+        pkt_len = struct.pack('H', len(packet_data))
+        #send packet
         self.conn.sendall(pkt_len)
-        self.conn.sendall(encrypted_data)
-
+        self.conn.sendall(packet_data)
+        return
+        
     def recv(self):
         # Decode the data's length from an unsigned two byte int ('H')
         pkt_len_packed = self.conn.recv(struct.calcsize('H'))
@@ -53,16 +100,75 @@ class StealthConn(object):
         pkt_len = unpacked_contents[0]
 
         encrypted_data = self.conn.recv(pkt_len)
+
         if self.cipher:
-            data = self.cipher.decrypt(encrypted_data)
+		    #recieved IV first 16 bytes
+            riv = encrypted_data[:16]
+			#recieved hmac 
+            rmac = encrypted_data[16:48]
+			#encrypted data
+            encrypted_data = encrypted_data[48:]
+
+			#decrypting data using recv IV
+            data = self.decrypt(encrypted_data, self.key, riv)
+            
+			#recv time stamp is last 24 bytes
+            recvtimest = data[-24:]
+			#actual data is data minus timestamp
+            data = data[:-24]
+			#reformat and read time stamp
+            recvtimest = time.mktime(time.strptime(recvtimest.decode("ascii"), "%a %b %d %H:%M:%S %Y"))
+            rTime = datetime.datetime.fromtimestamp(recvtimest)            
+            
+			#was message sent within the last 2 seconds
+            excTime = datetime.datetime.now() - datetime.timedelta(seconds=2)
+			#if not - return false
+            if rTime < excTime:
+                return False      
+
             if self.verbose:
                 print("Receiving packet of length {}".format(pkt_len))
                 print("Encrypted data: {}".format(repr(encrypted_data)))
                 print("Original data: {}".format(data))
         else:
-            data = encrypted_data
-
+            data = encrypted_data  
+                            
         return data
 
     def close(self):
         self.conn.close()
+        return
+		
+    #encrypt function with padding for AES - length 16
+    def encrypt(self, m, key):
+        mp = ANSI_X923_pad(m, 16)
+        cipher = AES.new(key, AES.MODE_CBC, self.iv)
+        return cipher.encrypt(mp)
+
+    #decrypt function with unpadding for AES - length 16
+    def decrypt(self, m, key, iv):
+        cipher = AES.new(key, AES.MODE_CBC, iv)
+        return ANSI_X923_unpad(cipher.decrypt(m), 16)
+
+#pad and unpad copied from week 02 Lab
+def ANSI_X923_pad(m, pad_length):
+    # Work out how many bytes need to be added
+    required_padding = pad_length - (len(m) % pad_length)
+    # Use a bytearray so we can add to the end of m
+    b = bytearray(m)
+    # Then k-1 zero bytes, where k is the required padding
+    b.extend(bytes("\x00" * (required_padding-1), "ascii"))
+    # And finally adding the number of padding bytes added
+    b.append(required_padding)
+    return bytes(b)
+
+def ANSI_X923_unpad(m, pad_length):
+    # The last byte should represent the number of padding bytes added
+    required_padding = m[-1]
+    # Ensure that there are required_padding - 1 zero bytes
+    if m.count(bytes([0]), -required_padding, -1) == required_padding - 1:
+        return m[:-required_padding]
+    else:
+        # Raise an exception in the case of an invalid padding
+        raise AssertionError("Padding was invalid")
+    return
\ No newline at end of file
